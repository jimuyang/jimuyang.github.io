<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"jimuyang.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":false,"version":"8.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/blog/js/config.js"></script>
<meta name="description" content="积木杨的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="积木杨">
<meta property="og:url" content="https://jimuyang.github.io/blog/index.html">
<meta property="og:site_name" content="积木杨">
<meta property="og:description" content="积木杨的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jimu Yang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://jimuyang.github.io/blog/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>积木杨</title>
  




  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">积木杨</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-schedule"><a href="/blog/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jimu Yang</p>
  <div class="site-description" itemprop="description">积木杨的博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jimuyang.github.io/blog/2019/12/22/%E5%9F%BA%E4%BA%8EGroovy%E7%9A%84%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Jimu Yang">
      <meta itemprop="description" content="积木杨的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="积木杨">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/12/22/%E5%9F%BA%E4%BA%8EGroovy%E7%9A%84%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">基于Groovy的规则引擎实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-22 23:00:09" itemprop="dateCreated datePublished" datetime="2019-12-22T23:00:09+08:00">2019-12-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-21 01:25:45" itemprop="dateModified" datetime="2021-10-21T01:25:45+08:00">2021-10-21</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>有些业务场景下(如判责、合规、仲裁)的逻辑繁杂且变化很快，开发经常需要根据业务需要频繁修改代码逻辑，影响心情，影响效率，而且还可能会背锅。 <a target="_blank" rel="noopener" href="https://github.com/jimuyang/rule-pile">github</a></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>基于 Java 运行时调用 Groovy 脚本的能力，可以让 Java 具备像脚本一样的灵活性。<br>核心代码：Java 执行 Groovy 脚本传参并获取结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成新的groovyClass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Class <span class="title">buildGroovyClass</span><span class="params">(String groovyScript)</span> <span class="keyword">throws</span> RuleException </span>&#123;</span><br><span class="line">    <span class="comment">// 每个class都new一个loader 便于垃圾回收</span></span><br><span class="line">    GroovyClassLoader loader = <span class="keyword">new</span> GroovyClassLoader();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loader.parseClass(groovyScript);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuleException(<span class="string">&quot;groovy脚本解析class出错:&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line"><span class="comment">// 获取groovyObject</span></span><br><span class="line">GroovyObject go = (GroovyObject) clazz.newInstance();</span><br><span class="line"><span class="comment">// 传参并调用脚本的main方法 </span></span><br><span class="line">Object result = groovyObject.invokeMethod(<span class="string">&quot;main&quot;</span>, input);</span><br></pre></td></tr></table></figure>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>有了基本原理后，其实问题被转变成了<code>如何生成Groovy脚本？</code>，理所当然的回答是：开发写呗。<br>这样的做法是可行的，但有几个问题：</p>
<ol>
<li>开发累死</li>
<li>容易出错</li>
<li>无法感受现有的逻辑  </li>
</ol>
<p>这里的解决方案是: 图编辑器-&gt;生成逻辑流程图-&gt;解析为Groovy脚本-&gt;执行。可见即可得<br><img src="/images/rulepile/flow2.jpg"></p>
<h2 id="图编辑器"><a href="#图编辑器" class="headerlink" title="图编辑器"></a>图编辑器</h2><p>图编辑器选择<code>g6</code>，准确来说选择开箱即用的<code>ant-design-pro</code>+<code>GGEditor</code>，前端要改的内容其实不多，为应对生成逻辑的需要，需要添加一些表单项即可<br><img src="/images/rulepile/flow3.jpg"></p>
<h2 id="解析图和逻辑依赖"><a href="#解析图和逻辑依赖" class="headerlink" title="解析图和逻辑依赖"></a>解析图和逻辑依赖</h2><p>编辑器的输出是<code>node</code>数组和<code>edge</code>数组，就是图上的节点和线们。后台解析这段json后，生成逻辑树。之后对逻辑树进行遍历后，生成最后的Groovy脚本。<br>逻辑树的遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursiveTravelNodeMap</span><span class="params">(Node node)</span> <span class="keyword">throws</span> RuleParseException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (node.getCategory()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;start&quot;</span>:</span><br><span class="line">           ···</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">           ···</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;logic&quot;</span>:</span><br><span class="line">           ···</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;common&quot;</span>:</span><br><span class="line">           ···</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// node的后续节点</span></span><br><span class="line">    <span class="keyword">for</span> (ConnectNode target : node.getTargets()) &#123;</span><br><span class="line">        ···</span><br><span class="line">        <span class="keyword">if</span> (BOOLEAN_TRUE.equalsIgnoreCase(stream) &amp;&amp; BOOLEAN_TRUE.equalsIgnoreCase(valve)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.recursiveTravelNodeMap(target.getNode());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.mainBuilder.append(<span class="string">&quot;if ((&quot;</span>).append(stream).append(<span class="string">&quot;).equals(&quot;</span>).append(valve).append(<span class="string">&quot;)) &#123;&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.recursiveTravelNodeMap(target.getNode());</span><br><span class="line">            <span class="keyword">this</span>.mainBuilder.append(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (defaultTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.recursiveTravelNodeMap(defaultTarget.getNode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了复用现有逻辑，提供了一套逻辑依赖的解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用模版生成函数main方法 脚本入口</span></span><br><span class="line">StringBuilder resultScript = <span class="keyword">new</span> StringBuilder(String.format(template,</span><br><span class="line">        mainRule.getRuleCode(), <span class="keyword">this</span>.buildFuncOptions(mainRule.getOptions(), <span class="keyword">true</span>)));</span><br><span class="line"><span class="comment">// 将依赖的规则函数体放入</span></span><br><span class="line"><span class="keyword">for</span> (RuRuleDefinition dependency : dependencies) &#123;</span><br><span class="line">    <span class="keyword">this</span>.expandResultScript(resultScript, dependency);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resultScript.toString();</span><br></pre></td></tr></table></figure>

<h2 id="具体设计"><a href="#具体设计" class="headerlink" title="具体设计"></a>具体设计</h2><p><img src="/images/rulepile/er.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jimuyang.github.io/blog/2019/12/22/Spring-Lazy%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Jimu Yang">
      <meta itemprop="description" content="积木杨的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="积木杨">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/12/22/Spring-Lazy%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Spring @Lazy的实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-22 15:26:12" itemprop="dateCreated datePublished" datetime="2019-12-22T15:26:12+08:00">2019-12-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-21 01:27:16" itemprop="dateModified" datetime="2021-10-21T01:27:16+08:00">2021-10-21</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Lazy的用途"><a href="#Lazy的用途" class="headerlink" title="@Lazy的用途"></a>@Lazy的用途</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Indicates whether a bean is to be lazily initialized.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;May be used on any class directly or indirectly annotated with &#123;@link</span><br><span class="line"> * org.springframework.stereotype.Component @Component&#125; or on methods annotated with</span><br><span class="line"> * &#123;@link Bean @Bean&#125;.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;If this annotation is not present on a &#123;@code @Component&#125; or &#123;@code @Bean&#125; definition,</span><br><span class="line"> * eager initialization will occur. If present and set to &#123;@code true&#125;, the &#123;@code @Bean&#125; or</span><br><span class="line"> * &#123;@code @Component&#125; will not be initialized until referenced by another bean or explicitly</span><br><span class="line"> * retrieved from the enclosing &#123;@link org.springframework.beans.factory.BeanFactory</span><br><span class="line"> * BeanFactory&#125;. If present and set to &#123;@code false&#125;, the bean will be instantiated on</span><br><span class="line"> * startup by bean factories that perform eager initialization of singletons.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;If Lazy is present on a &#123;@link Configuration @Configuration&#125; class, this</span><br><span class="line"> * indicates that all &#123;@code @Bean&#125; methods within that &#123;@code @Configuration&#125;</span><br><span class="line"> * should be lazily initialized. If &#123;@code @Lazy&#125; is present and false on a &#123;@code @Bean&#125;</span><br><span class="line"> * method within a &#123;@code @Lazy&#125;-annotated &#123;@code @Configuration&#125; class, this indicates</span><br><span class="line"> * overriding the &#x27;default lazy&#x27; behavior and that the bean should be eagerly initialized.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;In addition to its role for component initialization, this annotation may also be placed</span><br><span class="line"> * on injection points marked with &#123;@link org.springframework.beans.factory.annotation.Autowired&#125;</span><br><span class="line"> * or &#123;@link javax.inject.Inject&#125;: In that context, it leads to the creation of a</span><br><span class="line"> * lazy-resolution proxy for all affected dependencies, as an alternative to using</span><br><span class="line"> * &#123;@link org.springframework.beans.factory.ObjectFactory&#125; or &#123;@link javax.inject.Provider&#125;.</span><br></pre></td></tr></table></figure>

<p>官方注释写的也挺清楚，简单概括一下：</p>
<ol>
<li>写在<code>@Component</code>或者<code>@Bean</code>之前用于声明bean是否延迟初始化</li>
<li>写在<code>@Configuration</code>之前用于声明这个<code>Configuration</code>内的所有<code>Bean</code>是否延迟初始化</li>
<li>写在构造注入或者<code>@Autowired</code>之前用于声明是否延迟注入 此时注入的实际是一个<code>lazy-resolution proxy</code></li>
</ol>
<h1 id="分别学习-Lazy在这几个场景下如何实现"><a href="#分别学习-Lazy在这几个场景下如何实现" class="headerlink" title="分别学习@Lazy在这几个场景下如何实现"></a>分别学习@Lazy在这几个场景下如何实现</h1><h2 id="声明Bean延迟初始化"><a href="#声明Bean延迟初始化" class="headerlink" title="声明Bean延迟初始化"></a>声明Bean延迟初始化</h2><p>这个场景是比较容易理解，也比较容易想到实现的 </p>
<p>org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan 部分代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">    postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">    <span class="comment">// 这里做了注解的识别和处理</span></span><br><span class="line">    AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.springframework.context.annotation.AnnotationConfigUtils#processCommonDefinitionAnnotations 部分代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本质上还是setLazyInit属性</span></span><br><span class="line">AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);</span><br><span class="line"><span class="keyword">if</span> (lazy != <span class="keyword">null</span>) &#123;</span><br><span class="line">    abd.setLazyInit(lazy.getBoolean(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (abd.getMetadata() != metadata) &#123;</span><br><span class="line">    lazy = attributesFor(abd.getMetadata(), Lazy.class);</span><br><span class="line">    <span class="keyword">if</span> (lazy != <span class="keyword">null</span>) &#123;</span><br><span class="line">        abd.setLazyInit(lazy.getBoolean(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="申明延迟注入"><a href="#申明延迟注入" class="headerlink" title="申明延迟注入"></a>申明延迟注入</h2><p>demo代码：（这2个类都放在<code>com.example.demo</code>包下 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestComponent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AnotherComponent anotherComponent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(anotherComponent.hello());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">&quot;com.example.demo&quot;</span>);</span><br><span class="line">        TestComponent testComponent = (TestComponent) ac.getBean(<span class="string">&quot;testComponent&quot;</span>);</span><br><span class="line">        testComponent.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hi, I am another.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面也提到了，本质上inject的实际是一个<code>lazy-resolution proxy</code>，并不是原来的bean本身。分2部分看下源码:</p>
<ul>
<li>扫描并register<code>testComponent</code>时对lazy @Autowired的处理</li>
</ul>
<ol>
<li>在beanFactory初始化之后会预实例化<br>singleton:org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br></pre></td></tr></table></figure></li>
<li>实例化testComponent时 会注入它的依赖<br>org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveDependency<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">descriptor.initParameterNameDiscovery(<span class="keyword">this</span>.getParameterNameDiscoverer());</span><br><span class="line"><span class="keyword">if</span> (Optional.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.createOptionalDependency(descriptor, requestingBeanName);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory.class != descriptor.getDependencyType() &amp;&amp; ObjectProvider.class != descriptor.getDependencyType()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> DefaultListableBeanFactory.Jsr330Factory()).createDependencyProvider(descriptor, requestingBeanName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里判断和注入LazyResolutionProxy</span></span><br><span class="line">        Object result = <span class="keyword">this</span>.getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(descriptor, requestingBeanName);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = <span class="keyword">this</span>.doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultListableBeanFactory.DependencyObjectProvider(descriptor, requestingBeanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>判断和注入LazyResolutionProxy<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否是lazy依赖</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isLazy</span><span class="params">(DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Annotation ann : descriptor.getAnnotations()) &#123;</span><br><span class="line">        Lazy lazy = AnnotationUtils.getAnnotation(ann, Lazy.class);</span><br><span class="line">        <span class="keyword">if</span> (lazy != <span class="keyword">null</span> &amp;&amp; lazy.value()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodParameter methodParam = descriptor.getMethodParameter();</span><br><span class="line">    <span class="keyword">if</span> (methodParam != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Method method = methodParam.getMethod();</span><br><span class="line">        <span class="keyword">if</span> (method == <span class="keyword">null</span> || <span class="keyword">void</span>.class == method.getReturnType()) &#123;</span><br><span class="line">            Lazy lazy = AnnotationUtils.getAnnotation(methodParam.getAnnotatedElement(), Lazy.class);</span><br><span class="line">            <span class="keyword">if</span> (lazy != <span class="keyword">null</span> &amp;&amp; lazy.value()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建proxy</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">buildLazyResolutionProxy</span><span class="params">(<span class="keyword">final</span> DependencyDescriptor descriptor, <span class="keyword">final</span> <span class="meta">@Nullable</span> String beanName)</span> </span>&#123;</span><br><span class="line">    Assert.state(getBeanFactory() <span class="keyword">instanceof</span> DefaultListableBeanFactory,</span><br><span class="line">            <span class="string">&quot;BeanFactory needs to be a DefaultListableBeanFactory&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) getBeanFactory();</span><br><span class="line">    <span class="comment">// TargetSource是一个接口 用于提供实际要代理的target </span></span><br><span class="line">    <span class="comment">// 这里给到的实现是从beanFactory取得target</span></span><br><span class="line">    TargetSource ts = <span class="keyword">new</span> TargetSource() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; getTargetClass() &#123;</span><br><span class="line">            <span class="keyword">return</span> descriptor.getDependencyType();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这里从beanFactory中获取真正的bean</span></span><br><span class="line">            Object target = beanFactory.doResolveDependency(descriptor, beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class&lt;?&gt; type = getTargetClass();</span><br><span class="line">                <span class="keyword">if</span> (Map.class == type) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (List.class == type) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (Set.class == type || Collection.class == type) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(descriptor.getResolvableType(),</span><br><span class="line">                        <span class="string">&quot;Optional dependency not present for lazy injection point&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ProxyFactory pf = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    pf.setTargetSource(ts);</span><br><span class="line">    Class&lt;?&gt; dependencyType = descriptor.getDependencyType();</span><br><span class="line">    <span class="keyword">if</span> (dependencyType.isInterface()) &#123;</span><br><span class="line">        pf.addInterface(dependencyType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里生成proxy</span></span><br><span class="line">    <span class="keyword">return</span> pf.getProxy(beanFactory.getBeanClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>生成proxy 分为jdk(JdkDynamicAopProxy)和cglib(CglibAopProxy)<br>org.springframework.aop.framework.DefaultAopProxyFactory#createAopProxy<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !<span class="keyword">this</span>.hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">    <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass) ? <span class="keyword">new</span> ObjenesisCglibAopProxy(config) : <span class="keyword">new</span> JdkDynamicAopProxy(config));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复习下：spring的动态代理在没给具体类或者面向接口时使用jdk(本质是Proxy实现了代理接口 反射调用方法)，其他使用cglib(本质是生成被代理类的子类 FastClass机制直接调用原方法) </p>
</blockquote>
</li>
<li>proxy中对方法的拦截 这里jdk和cglib行为相似<br>关键在于这里调用了<code>targetSource.getTarget()</code>来从beanFactory获取bean从而触发了init 核心代码:</li>
</ol>
<p>org.springframework.aop.framework.JdkDynamicAopProxy#invoke</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">target = targetSource.getTarget();</span><br><span class="line">Class&lt;?&gt; targetClass = target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>;</span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"><span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">    Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">    retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    MethodInvocation invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">    retVal = invocation.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.springframework.aop.framework.CglibAopProxy.DynamicAdvisedInterceptor#intercept</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">target = targetSource.getTarget();</span><br><span class="line">Class&lt;?&gt; targetClass = target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>;</span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">Object retVal;</span><br><span class="line"><span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">    Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">    retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    retVal = (<span class="keyword">new</span> CglibAopProxy.CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy)).proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>@Lazy可用于bean的延迟初始化(asm获取类注解)和bean依赖的延迟注入(动态代理)</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jimuyang.github.io/blog/2019/12/22/Java-CodeBook/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Jimu Yang">
      <meta itemprop="description" content="积木杨的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="积木杨">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/12/22/Java-CodeBook/" class="post-title-link" itemprop="url">Java CodeBook</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-22 15:14:02" itemprop="dateCreated datePublished" datetime="2019-12-22T15:14:02+08:00">2019-12-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-19 18:53:30" itemprop="dateModified" datetime="2021-10-19T18:53:30+08:00">2021-10-19</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="推荐使用-try-with-resources-来安全的-close-资源"><a href="#推荐使用-try-with-resources-来安全的-close-资源" class="headerlink" title="推荐使用 try-with-resources 来安全的 close 资源"></a>推荐使用 try-with-resources 来安全的 close 资源</h2><p>要使用 try-with-resources，资源必须实现 AutoCloseable 接口，给出一些例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">readFirstLine</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同时使用多个资源</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(dst)) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = in.read(buf)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于异常处理"><a href="#关于异常处理" class="headerlink" title="关于异常处理"></a>关于异常处理</h3><p>try-with-resources 一共有 3 个步骤</p>
<ol>
<li>小括号内的代码块 一般为打开资源</li>
<li>大号内的代码块 一般为使用资源</li>
<li>隐藏的 close 调用 实现了 AutoCloseable 的资源会被 close</li>
</ol>
<p>这 3 个阶段都可能抛出异常</p>
<ol>
<li>小括号内的代码块出现异常 =&gt; 直接抛出 不再执行下 2 个阶段</li>
<li>大括号内的代码块出现异常 =&gt; 继续执行 close 阶段 保证资源正常 close 后抛出异常</li>
<li>隐藏的 close 调用出现异常 =&gt; 如果 2 阶段没有异常则抛出异常 否则将自己的异常信息加入到 2 阶段异常的堆栈中</li>
</ol>
<p>给出测试代码 可以分别注释 3 个阶段的异常抛出代码进行测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoCloseResource</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    AutoCloseResource() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;open资源出现异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;close资源出现异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTryResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (AutoCloseResource res = <span class="keyword">new</span> AutoCloseResource()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;使用资源出现异常&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出 2、3 阶段都出现异常时的堆栈信息，可以明显看到 close 阶段的异常被<code>Suppressed</code>但信息还在，方便排错，可以编程通过<code>e.getSuppressed()</code>方法访问到这些信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Exception: 使用资源出现异常</span><br><span class="line">	at Test.testTryResource(Test.java:69)</span><br><span class="line">	at Test.main(Test.java:53)</span><br><span class="line">	Suppressed: java.lang.Exception: close资源出现异常</span><br><span class="line">		at Test<span class="variable">$AutoCloseResource</span>.close(Test.java:63)</span><br><span class="line">		at Test.testTryResource(Test.java:70)</span><br><span class="line">		... 1 more</span><br></pre></td></tr></table></figure>

<h2 id="并发-安全的终止线程"><a href="#并发-安全的终止线程" class="headerlink" title="并发-安全的终止线程"></a>并发-安全的终止线程</h2><h3 id="正确示范"><a href="#正确示范" class="headerlink" title="正确示范"></a>正确示范</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stop &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Test runner = <span class="keyword">new</span> Test();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runner, <span class="string">&quot;runnerThread&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1L</span>);</span><br><span class="line">        runner.stop();</span><br><span class="line">        <span class="comment">// runner.interrupt(); // 这样线程反应要更快 毕竟interrupt0()是native</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误示范-1"><a href="#错误示范-1" class="headerlink" title="错误示范 1"></a>错误示范 1</h3><p>来自《Effective Java》，如书中所说我对下面这段程序的预测也是运行超过 1 秒钟，但本机测试后，这个程序永远没有停止。。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> stop;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Test runner = <span class="keyword">new</span> Test();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runner, <span class="string">&quot;runnerThread&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1L</span>);</span><br><span class="line">        runner.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>书中给了简单的解释是因为 JVM 会将下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!stop) &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么是谁出于什么目的依照什么标准在什么阶段完成的上述优化呢？这个问题完全值得深挖一篇新博客了，留坑。这里先做一个简单的回答：</p>
<blockquote>
<p><code>JIT编译器</code>(Just In Time Compiler)出于提高<code>热点代码</code>的执行效率的目的按照<code>JMM</code>(Java 内存模型)的指导(在这里其实是没做要求)在<code>运行时</code>(Runtime)完成的<code>循环表达式外提</code>(Loop Expression Hoisting)优化。也就是书中的“提升”。</p>
</blockquote>
<p>可以通过参数 <strong>-Xint</strong> 来强制 JVM 运行于<code>解释模式</code>(Interpreted Mode)来让 JIT 不工作，此时上面的代码会如想象般运行超过 1s 但最终停止。</p>
<h2 id="设计模式-Demo"><a href="#设计模式-Demo" class="headerlink" title="设计模式 Demo"></a>设计模式 Demo</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ol>
<li>提前初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">// 构造方法私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>内部类实现懒汉</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Double-Check</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// volatile保证未完成初始化的对象不会漏出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 构造方法私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时还是有几个小问题：</p>
</blockquote>
<ul>
<li>可能通过反射调用私有的构造方法</li>
<li>序列化问题 readObject()永远返回一个新的实例</li>
</ul>
<ol start="4">
<li>最佳实践 枚举实现单例</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HolderEnum.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">HolderEnum</span> </span>&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">HolderEnum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>接口及实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Square::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Circle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步优化:通过配置来实现加载不同的实现类</p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>使用工厂来创建工厂</p>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>使用一个 Builder 来一步步构造最终的对象 可用来实现不可变类 可方便的使用<code>Lombok</code> <code>@Builder</code>来使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = builder.name;</span><br><span class="line">        <span class="keyword">this</span>.gender = builder.gender;</span><br><span class="line">        <span class="keyword">this</span>.age = builder.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 必须参数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="comment">// 可选参数 初值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> gender = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">gender</span><span class="params">(<span class="keyword">int</span> gender)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.gender = gender;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用起来和具名参数一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person.Builder(<span class="string">&quot;xiaoming&quot;</span>).gender(<span class="number">1</span>).age(<span class="number">18</span>).build();</span><br></pre></td></tr></table></figure>

<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>用于创建重复的对象，同时又能保证性能。 例如 Java 中的 Object.clone()</p>
<p>说明：Java 中的 clone 需要保证 1) a.clone() != a 2) a.clone().getClass() == a.getClass() 不强求：a.clone().equals(a)<br>对于除了基本类型和不可变类以外的成员变量，注意深拷贝<br>下面的栗子代码虽然没有给出 equals 方法的实现 但显而易见没有保证 person.clone().equals(person)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Person <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">super</span>.clone();</span><br><span class="line">        Person clone = (Person) o;</span><br><span class="line">        clone.age = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>接口转换 以双线插头适配三线插座为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoWirePlug</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fireWire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火线&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">zeroWire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;零线&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ThreeWirePlug</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fireWire</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">zeroWire</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">landWire</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">ThreeWirePlug</span> </span>&#123;</span><br><span class="line">    TwoWirePlug twoWirePlug;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fireWire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.twoWirePlug.fireWire();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">zeroWire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.twoWirePlug.zeroWire();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">landWire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;地线不接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>桥接 2 个独立变化的维度 偏向组装的概念</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>钉钉机器人的实现</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。<br>关键在于在 Subject 中存放 observer 列表</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>大量行为不同的类 代表不同的策略<br>事件处理方案的实现</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>Spring aop</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jimuyang.github.io/blog/2019/12/22/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84RPC%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Jimu Yang">
      <meta itemprop="description" content="积木杨的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="积木杨">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/12/22/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84RPC%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">基于Netty的RPC实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-22 01:10:20" itemprop="dateCreated datePublished" datetime="2019-12-22T01:10:20+08:00">2019-12-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-19 18:53:30" itemprop="dateModified" datetime="2021-10-19T18:53:30+08:00">2021-10-19</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基于Netty实现一个RPCServer"><a href="#基于Netty实现一个RPCServer" class="headerlink" title="基于Netty实现一个RPCServer"></a>基于Netty实现一个RPCServer</h1><p>容易想到也容易实现的是一个Json协议的HTTP Server，用起来大概像这个样子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl POST <span class="string">&#x27;localhost:5031/rpc&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">--data-raw <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">	&quot;interface&quot;:&quot;muyi.jnpc.server.api.TestService&quot;,</span></span><br><span class="line"><span class="string">	&quot;method&quot;:&quot;sayHi&quot;,</span></span><br><span class="line"><span class="string">	&quot;args&quot;:&#123;</span></span><br><span class="line"><span class="string">		&quot;name&quot;: &quot;\&quot;muyi\&quot;&quot;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>那么想象中<code>RPCClient</code>也是通过将rpc调用转化为http请求来调用<code>RPCServer</code>，<strong>KISS</strong>。</p>
<h1 id="基于Netty实现一个RPCClient"><a href="#基于Netty实现一个RPCClient" class="headerlink" title="基于Netty实现一个RPCClient"></a>基于Netty实现一个RPCClient</h1><h1 id="通过Spring来简化RPC接口的服务端暴露和用户端声明"><a href="#通过Spring来简化RPC接口的服务端暴露和用户端声明" class="headerlink" title="通过Spring来简化RPC接口的服务端暴露和用户端声明"></a>通过Spring来简化RPC接口的服务端暴露和用户端声明</h1><h1 id="池化RPCServer和RPCClient"><a href="#池化RPCServer和RPCClient" class="headerlink" title="池化RPCServer和RPCClient"></a>池化RPCServer和RPCClient</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jimuyang.github.io/blog/2019/11/24/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8CGo%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Jimu Yang">
      <meta itemprop="description" content="积木杨的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="积木杨">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/11/24/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8CGo%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">红黑树和Go实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-24 13:57:45" itemprop="dateCreated datePublished" datetime="2019-11-24T13:57:45+08:00">2019-11-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-21 01:26:23" itemprop="dateModified" datetime="2021-10-21T01:26:23+08:00">2021-10-21</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="为什么需要红黑树"><a href="#为什么需要红黑树" class="headerlink" title="为什么需要红黑树"></a>为什么需要红黑树</h2><p>红黑树是一种特殊的二叉搜索树。因为它的时间复杂度也是 O(h)，h是树的高度。而红黑树是一种较矮的二叉搜索树，它的定义确保了从根到叶子的任何一条路径会比其他路径长出2倍，因而是近似于平衡的。<br>本文使用golang实现红黑树的基本方法，全部代码加注释不到400行，主要的思路来自《算法导论》第13章红黑树。</p>
<h2 id="红黑树的定义"><a href="#红黑树的定义" class="headerlink" title="红黑树的定义"></a>红黑树的定义</h2><ol>
<li>红黑原则: 每个节点是红色或者黑色</li>
<li>黑根原则: 根节点(root)和叶子节点(LEAF)为黑色</li>
<li>连红原则: 如果一个节点是红色，则它的子节点都是黑色</li>
<li>黑高原则: 对每个节点，从该节点到其所有后代叶节点的简单路径上，包含相同数目的黑色节点</li>
</ol>
<h3 id="一些解读："><a href="#一些解读：" class="headerlink" title="一些解读："></a>一些解读：</h3><ul>
<li>红黑树的以黑色节点为根的子树也是红黑树</li>
<li>连红原则 =&gt; 不能连续出现红色节点，结合黑高原则可知在极端场景下，一条路径A上红黑节点间隔出现，它的长度是另一条路径B（只有黑节点）的2倍</li>
</ul>
<h2 id="快速用Golang实现吧"><a href="#快速用Golang实现吧" class="headerlink" title="快速用Golang实现吧"></a>快速用Golang实现吧</h2><h3 id="定义红黑树的节点"><a href="#定义红黑树的节点" class="headerlink" title="定义红黑树的节点"></a>定义红黑树的节点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RBNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	value               <span class="keyword">int64</span></span><br><span class="line">	color               <span class="keyword">bool</span></span><br><span class="line">	left, right, parent *RBNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和普通的二叉搜索树只是多了一个color字段，值为常量 如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// RED 红色</span></span><br><span class="line">	RED <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">	<span class="comment">// BLACK 黑色</span></span><br><span class="line">	BLACK <span class="keyword">bool</span> = <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>定义几个概念：注意下面的方法都没有做判空，由使用者来保证</p>
<ul>
<li>爷节点 - 父节点的父节点  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *RBNode)</span> <span class="title">getGrandPa</span><span class="params">()</span> *<span class="title">RBNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> node.parent.parent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>兄弟节点 - 顾名思义   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *RBNode)</span> <span class="title">getBrother</span><span class="params">()</span> *<span class="title">RBNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node == node.parent.left &#123;</span><br><span class="line">		<span class="keyword">return</span> node.parent.right</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node.parent.left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>叔节点 - 父节点的兄弟节点  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *RBNode)</span> <span class="title">getUncle</span><span class="params">()</span> *<span class="title">RBNode</span></span> &#123;</span><br><span class="line">	grandPa := node.getGrandPa()</span><br><span class="line">	<span class="keyword">if</span> grandPa.left == node.parent &#123;</span><br><span class="line">		<span class="keyword">return</span> grandPa.right</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> grandPa.left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="定义红黑树"><a href="#定义红黑树" class="headerlink" title="定义红黑树"></a>定义红黑树</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RBTree <span class="keyword">struct</span> &#123;</span><br><span class="line">	root *RBNode</span><br><span class="line">	LEAF *RBNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Init 初始化一颗红黑树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *RBTree)</span> <span class="title">Init</span><span class="params">()</span> *<span class="title">RBTree</span></span> &#123;</span><br><span class="line">	tree.LEAF = &amp;RBNode&#123;<span class="number">0</span>, BLACK, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">	tree.root = tree.LEAF</span><br><span class="line">	<span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于LEAF节点（叶节点）的说明：它是<strong>唯一</strong>的叶节点，它的颜色为黑色<br>看2个使用场景:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> node != tree.LEAF &#123;</span><br><span class="line">    <span class="comment">// node不是叶节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向树中插入新节点时的构建 左右子节点都是LEAF</span></span><br><span class="line">newNode := &amp;RBNode&#123;value, RED, tree.LEAF, tree.LEAF, parent&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个小疑问：为什么不使用nil作为叶节点？此时只要认为nil也是黑色不就可以达到相同的目的么<br>我一开始就是这么做的并且没觉得有啥问题，直到在实现红黑树的删除时…，在后续逻辑中有体现   </p>
</blockquote>
<h3 id="红黑树的查询、最大值、最小值"><a href="#红黑树的查询、最大值、最小值" class="headerlink" title="红黑树的查询、最大值、最小值"></a>红黑树的查询、最大值、最小值</h3><p>和普通二叉树的查询没有任何区别</p>
<h4 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find 红黑树中找到一个值 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *RBTree)</span> <span class="title">Find</span><span class="params">(value <span class="keyword">int64</span>)</span> *<span class="title">RBNode</span></span> &#123;</span><br><span class="line">	node := tree.root</span><br><span class="line">	<span class="keyword">for</span> node != tree.LEAF &amp;&amp; node.value != value &#123;</span><br><span class="line">		<span class="keyword">if</span> value &lt; node.value &#123;</span><br><span class="line">			node = node.left</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			node = node.right</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Min"><a href="#Min" class="headerlink" title="Min"></a>Min</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Min 红黑树的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *RBTree)</span> <span class="title">Min</span><span class="params">()</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">	minNode := tree.minNode(tree.root)</span><br><span class="line">	<span class="keyword">if</span> minNode == tree.LEAF &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;空树&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> minNode.value, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="minNode"><a href="#minNode" class="headerlink" title="minNode"></a>minNode</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在以start为根的子树中寻找最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *RBTree)</span> <span class="title">minNode</span><span class="params">(start *RBNode)</span> *<span class="title">RBNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> start == tree.LEAF &#123;</span><br><span class="line">		<span class="keyword">return</span> tree.LEAF</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> start.left != tree.LEAF &#123;</span><br><span class="line">		start = start.left</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Max 和Min没啥区别，篇幅原因忽略</span></span><br></pre></td></tr></table></figure>
<h3 id="红黑树的测试"><a href="#红黑树的测试" class="headerlink" title="红黑树的测试"></a>红黑树的测试</h3><p>测试我们实现的红黑树是否违反了几大原则 这里给出一个递归版本的简单测试</p>
<h4 id="Check"><a href="#Check" class="headerlink" title="Check"></a>Check</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check 检查红黑树是否违反原则</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *RBTree)</span> <span class="title">Check</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> tree.root.color == RED &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;违反黑根原则&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	_, err := tree.check(tree.root)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回以node为根的子树的黑高</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *RBTree)</span> <span class="title">check</span><span class="params">(node *RBNode)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node == tree.LEAF &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> node.color == RED &#123;</span><br><span class="line">		<span class="keyword">if</span> node.left.color == RED || node.right.color == RED &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;违反连红原则&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 左右子树的黑高</span></span><br><span class="line">	lc, err := tree.check(node.left)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	rc, err := tree.check(node.right)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> lc != rc &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;违反黑高原则&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 自己的黑高</span></span><br><span class="line">	bh := lc</span><br><span class="line">	<span class="keyword">if</span> node.color == BLACK &#123;</span><br><span class="line">		bh++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bh, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="红黑树的旋转"><a href="#红黑树的旋转" class="headerlink" title="红黑树的旋转"></a>红黑树的旋转</h3><p>在实现红黑树的插入和删除之前，先实现红黑树的旋转吧，和普通二叉树的实现没有区别。<br>在旋转的实现中，只有指针的修改。需要注意的点只有：</p>
<ol>
<li>如果原来是root节点，需要修改root的指向</li>
<li>这里不要随便改变LEAF的parent指向</li>
</ol>
<h4 id="leftRotate"><a href="#leftRotate" class="headerlink" title="leftRotate"></a>leftRotate</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左旋 将node的右孩子旋转到自己的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *RBTree)</span> <span class="title">leftRotate</span><span class="params">(node *RBNode)</span> <span class="params">(*RBNode, error)</span></span> &#123;</span><br><span class="line">	rc := node.right</span><br><span class="line">	<span class="keyword">if</span> rc == tree.LEAF &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;右孩子不存在, 无法左旋&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 右孩子的左孩子“过继”给自己当右孩子</span></span><br><span class="line">	node.right = rc.left</span><br><span class="line">	<span class="comment">// 这里不希望随便改变LEAF的parent</span></span><br><span class="line">	<span class="keyword">if</span> rc.left != tree.LEAF &#123;</span><br><span class="line">		rc.left.parent = node</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 右孩子上位</span></span><br><span class="line">	rc.parent = node.parent</span><br><span class="line">	<span class="keyword">if</span> node.parent == tree.LEAF &#123;</span><br><span class="line">		<span class="comment">// 本来是根节点</span></span><br><span class="line">		tree.root = rc</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> node.parent.left == node &#123;</span><br><span class="line">		node.parent.left = rc</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		node.parent.right = rc</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 自己成为左孩子</span></span><br><span class="line">	rc.left = node</span><br><span class="line">	node.parent = rc</span><br><span class="line">	<span class="keyword">return</span> rc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右旋 将node的左孩子旋转到自己的位置</span></span><br><span class="line"><span class="comment">// 和左旋只是方向不同 这里不再给到...</span></span><br></pre></td></tr></table></figure>

<h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h3><p>红黑树的插入和普通二叉树的插入没有大的区别，关键点是：</p>
<ol>
<li>新增的是红色节点 =&gt; 此时可能违反的是黑根原则和连红原则</li>
<li>在保证黑高原则永远不被违反的前提下，将树变色和旋转来处理连红的情况</li>
</ol>
<h4 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h4><p>没啥好说的 只是在合适的位置插入了一个红色的新节点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Insert 红黑树中插入一个新值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *RBTree)</span> <span class="title">Insert</span><span class="params">(value <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	node := tree.root</span><br><span class="line">	<span class="keyword">var</span> parent *RBNode = tree.LEAF</span><br><span class="line">	<span class="comment">// 找到合适的插入位置</span></span><br><span class="line">	<span class="keyword">for</span> node != tree.LEAF &#123;</span><br><span class="line">		parent = node</span><br><span class="line">		<span class="keyword">if</span> value &lt; node.value &#123;</span><br><span class="line">			node = node.left</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			node = node.right</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 放入一个红色节点</span></span><br><span class="line">	newNode := &amp;RBNode&#123;value, RED, tree.LEAF, tree.LEAF, parent&#125;</span><br><span class="line">	<span class="keyword">if</span> parent == tree.LEAF &#123;</span><br><span class="line">		<span class="comment">// 空树</span></span><br><span class="line">		tree.root = newNode</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> value &lt; parent.value &#123;</span><br><span class="line">		parent.left = newNode</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		parent.right = newNode</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调整红黑树 使之依然保持红黑</span></span><br><span class="line">	tree.insertFixup(newNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="insertFixup"><a href="#insertFixup" class="headerlink" title="insertFixup"></a>insertFixup</h4><p>旋转和变色 使之保持红黑。其中的关键是一直保持黑高原则不被打破<br>被打破的只有：</p>
<ol>
<li>黑根原则 =&gt; 根节点变色即可</li>
<li>连红原则 此时分情况提供解决方案：</li>
</ol>
<ul>
<li>如果父节点和叔节点都是红色 =&gt; 双变色：父节点和叔节点都变黑 爷节点变红<br><img src="/images/rbtree/1.jpg"></li>
<li>如果父节点红、叔节点黑    =&gt; 统一战线干掉爷节点：保证我、父、爷成一条直线，然后旋转挤下爷节点<br><img src="/images/rbtree/2.jpg"><br>从图上可以看出在不看红节点的视角下，所有子树都接在一个黑节点上，旋转过后依然如此，因此黑高原则没有被打破<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *RBTree)</span> <span class="title">insertFixup</span><span class="params">(newNode *RBNode)</span></span> &#123;</span><br><span class="line">	redNode := newNode</span><br><span class="line">	<span class="keyword">for</span> redNode.parent.color == RED &#123;</span><br><span class="line">		parent := redNode.parent</span><br><span class="line">		uncle, grandPa := redNode.getUncle(), redNode.getGrandPa()</span><br><span class="line">		<span class="keyword">if</span> uncle.color == RED &#123;</span><br><span class="line">			<span class="comment">// 如果叔节点是红色 =&gt; 双变色</span></span><br><span class="line">			parent.color = BLACK</span><br><span class="line">			uncle.color = BLACK</span><br><span class="line">			grandPa.color = RED</span><br><span class="line">			redNode = grandPa</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果叔节点是黑色 =&gt; 统一战线干掉爷节点</span></span><br><span class="line">			<span class="keyword">if</span> redNode == parent.left &amp;&amp; parent == grandPa.right &#123;</span><br><span class="line">				parent, _ = tree.rightRotate(parent)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> redNode == parent.right &amp;&amp; parent == grandPa.left &#123;</span><br><span class="line">				parent, _ = tree.leftRotate(parent)</span><br><span class="line">			&#125;</span><br><span class="line">			parent.color = BLACK</span><br><span class="line">			grandPa.color = RED</span><br><span class="line">			<span class="keyword">if</span> parent == grandPa.left &#123;</span><br><span class="line">				tree.rightRotate(grandPa)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				tree.leftRotate(grandPa)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	tree.root.color = BLACK</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h3>在实现删除之前，先实现一个子过程transplant，这个方法通过子节点上移的方式来删除父节点<h4 id="transplant"><a href="#transplant" class="headerlink" title="transplant"></a>transplant</h4>这里有一个关键点：子节点可能是LEAF，此时也需要赋值parent来记录自己的位置；这里也是叶节点不用nil来实现的理由<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移植 子节点move上移替代原来的节点 只有指针的赋值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *RBTree)</span> <span class="title">transplant</span><span class="params">(deleted *RBNode, move *RBNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> deleted.parent == tree.LEAF &#123;</span><br><span class="line">		tree.root = move</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> deleted == deleted.parent.left &#123;</span><br><span class="line">		deleted.parent.left = move</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		deleted.parent.right = move</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里move可能是LEAF 也需要修改parent来记录自己的位置</span></span><br><span class="line">	move.parent = deleted.parent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h4>从红黑树中删除一个值需要2步：1. 找到这个值 2.删掉它<br>其中的关键点是：从树中删除一个节点，往往实际删除的是它的后继节点<br><img src="/images/rbtree/3.jpg"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete 从红黑树中删除一个值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *RBTree)</span> <span class="title">Delete</span><span class="params">(value <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	node := tree.Find(value)</span><br><span class="line">	<span class="keyword">if</span> node == tree.LEAF &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;树中没有该值 无法删除&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tree.deleteNode(node)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从红黑树中删除一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *RBTree)</span> <span class="title">deleteNode</span><span class="params">(node *RBNode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 实际上移的节点</span></span><br><span class="line">	<span class="keyword">var</span> move *RBNode</span><br><span class="line">	<span class="comment">// 实际少了的颜色</span></span><br><span class="line">	color := node.color</span><br><span class="line">	<span class="keyword">if</span> node.left == tree.LEAF &#123;</span><br><span class="line">		<span class="comment">// 右子树上移</span></span><br><span class="line">		move = node.right</span><br><span class="line">		tree.transplant(node, move)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> node.right == tree.LEAF &#123;</span><br><span class="line">		<span class="comment">// 左子树上移</span></span><br><span class="line">		move = node.left</span><br><span class="line">		tree.transplant(node, move)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 目标节点有2个子节点，此时找到目标节点右子树的最小值（即后继节点）</span></span><br><span class="line">		<span class="comment">// 将后继节点赋值给目标节点后，此时实际要删除的是后继节点</span></span><br><span class="line">		<span class="comment">// 后继节点的左子树一定为LEAF 将后继节点的右子树上移</span></span><br><span class="line">		successor := tree.minNode(node)</span><br><span class="line">		node.value = successor.value</span><br><span class="line">		color = successor.color</span><br><span class="line">		move = successor.right</span><br><span class="line">		tree.transplant(successor, move)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> color == BLACK &#123;</span><br><span class="line">		<span class="comment">// 树里少了一个黑色 此时需要fixup</span></span><br><span class="line">		<span class="comment">// 黑高原则还是不容打破 此时我们认为上移的节点move拥有额外的一个黑色</span></span><br><span class="line">		<span class="comment">// 此时move的颜色为红黑(RED)或黑黑(BLACK) 此时违反了 红黑原则</span></span><br><span class="line">		<span class="comment">// move此时可能为LEAF 但在transplant中也赋值了parent</span></span><br><span class="line">		tree.deleteFixup(move)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="deleteFixup"><a href="#deleteFixup" class="headerlink" title="deleteFixup"></a>deleteFixup</h4><p>这个方法的核心思路是被删除节点后，认为实际上移的节点move拥有额外的一个黑色。此时一切都好，只是红黑原则被打破了。<br>deleteFixup方法就是要处理这额外的黑色，手段是将这个黑色上移，直到：</p>
<ul>
<li>node为一个红黑节点 =&gt; 直接染成黑色即可</li>
<li>node指向了根节点 =&gt; 将额外的黑色移除</li>
<li>适当的旋转和着色从而退出循环</li>
</ul>
<p>主要讨论node是黑黑节点且不是根节点的情况，下面分析基于一个假设：node是左孩子、兄弟是右孩子的情况，因为node是右孩子是完全对称的情形</p>
<ol>
<li>如果兄弟节点是红色的 左旋让兄弟变成黑的<br><img src="/images/rbtree/4.jpg"></li>
<li>如果兄弟节点是黑色</li>
</ol>
<ul>
<li>2.1 兄弟的子女都是黑的 就可以和兄弟一起脱黑 额外的黑转移给父节点<br><img src="/images/rbtree/5.jpg"></li>
<li>2.2 兄弟的右孩子是红的 左旋即可 （拉父节点下水 让父节点承担额外的黑 解决问题<br><img src="/images/rbtree/6.jpg"></li>
<li>2.3 兄弟的左孩子是红的 兄弟右旋让右孩子变红 回到2.2<br><img src="/images/rbtree/7.jpg"></li>
</ul>
<p>代码实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *RBTree)</span> <span class="title">deleteFixup</span><span class="params">(moveNode *RBNode)</span></span> &#123;</span><br><span class="line">	<span class="comment">// node节点自带一层黑色 这里的node可能为LEAF 但带了parent</span></span><br><span class="line">	node := moveNode</span><br><span class="line">	<span class="comment">// 是黑黑节点且不是根节点 此时需要处理额外的黑色 此时兄弟节点一定不为LEAF</span></span><br><span class="line">	<span class="keyword">for</span> node.color == BLACK &amp;&amp; node != tree.root &#123;</span><br><span class="line">		<span class="comment">// 分类讨论: 下面只看我是左孩子 兄弟是右孩子的情况</span></span><br><span class="line">		<span class="comment">// 1. 如果兄弟节点是红色的 左旋让兄弟变成黑的</span></span><br><span class="line">		<span class="comment">// 2. 如果兄弟节点是黑的</span></span><br><span class="line">		<span class="comment">//    2.1 兄弟的子女都是黑的 就可以和兄弟一起脱黑 额外的黑转移给父节点</span></span><br><span class="line">		<span class="comment">//    2.2 兄弟的右孩子是红的 左旋即可 （拉父节点下水 让父节点承担额外的黑 解决问题</span></span><br><span class="line">		<span class="comment">//    2.3 兄弟的左孩子是红的 兄弟右旋让右孩子变红 回到2.2</span></span><br><span class="line">		brother := node.getBrother()</span><br><span class="line">		amLeft := node == node.parent.left</span><br><span class="line">		<span class="keyword">if</span> brother.color == RED &#123;</span><br><span class="line">			<span class="comment">// 此时parent是黑的 brother的2个子节点都不为LEAF且都是黑的</span></span><br><span class="line">			node.parent.color = RED</span><br><span class="line">			brother.color = BLACK</span><br><span class="line">			tree.rotate(node.parent, amLeft)</span><br><span class="line">			<span class="comment">// 此时兄弟已经换了 新兄弟一定不为LEAF 且一定是黑色（看图参考黑高原则）</span></span><br><span class="line">			brother = node.getBrother()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 此时兄弟是黑的</span></span><br><span class="line">		<span class="keyword">if</span> brother.left.color == BLACK &amp;&amp; brother.right.color == BLACK &#123;</span><br><span class="line">			<span class="comment">// 可以和兄弟一起脱黑</span></span><br><span class="line">			brother.color = RED</span><br><span class="line">			<span class="comment">// 额外的黑色转移到父节点</span></span><br><span class="line">			node = node.parent</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 不能一起脱黑 那就旋转变色 解决问题</span></span><br><span class="line">			<span class="keyword">if</span> amLeft &#123;</span><br><span class="line">				<span class="keyword">if</span> brother.left.color == RED &#123;</span><br><span class="line">					brother.left.color = BLACK</span><br><span class="line">					brother.color = RED</span><br><span class="line">					tree.rightRotate(brother)</span><br><span class="line">				&#125;</span><br><span class="line">				brother = node.parent.right</span><br><span class="line">				<span class="comment">// 此时brother的右孩子一定是红色 整体左旋</span></span><br><span class="line">				brother.color = node.parent.color</span><br><span class="line">				node.parent.color = BLACK <span class="comment">// 背额外的黑</span></span><br><span class="line">				brother.right.color = BLACK</span><br><span class="line">				tree.leftRotate(node.parent)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> brother.right.color == RED &#123;</span><br><span class="line">					brother.right.color = BLACK</span><br><span class="line">					brother.color = RED</span><br><span class="line">					tree.leftRotate(brother)</span><br><span class="line">				&#125;</span><br><span class="line">				brother = node.parent.left</span><br><span class="line">				<span class="comment">// 此时brother的左孩子一定是红色 整体右旋</span></span><br><span class="line">				brother.color = node.parent.color</span><br><span class="line">				node.parent.color = BLACK <span class="comment">// 背额外的黑</span></span><br><span class="line">				brother.left.color = BLACK</span><br><span class="line">				tree.rightRotate(node.parent)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 是红黑节点或者是根节点 简单的染成黑色即可</span></span><br><span class="line">	node.color = BLACK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现测试"><a href="#实现测试" class="headerlink" title="实现测试"></a>实现测试</h2><p>这里给出一个简单的测试</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tree := <span class="built_in">new</span>(RBTree).Init()</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">	rand.Seed(time.Now().Unix())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		arr[i] = rand.Intn(<span class="number">1000</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, e := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;insert: %d \n&quot;</span>, e)</span><br><span class="line">		tree.Insert(<span class="keyword">int64</span>(e))</span><br><span class="line">		err := tree.Check()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, e := <span class="keyword">range</span> arr[<span class="number">40</span>:<span class="number">80</span>] &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;delete: %d \n&quot;</span>, e)</span><br><span class="line">		tree.Delete(<span class="keyword">int64</span>(e))</span><br><span class="line">		err := tree.Check()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本文的全部代码在 <a target="_blank" rel="noopener" href="https://github.com/jimuyang/lets-go/blob/master/algorithms/RedBlackTree.go">https://github.com/jimuyang/lets-go/blob/master/algorithms/RedBlackTree.go</a> 欢迎意见和交流😊</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jimuyang.github.io/blog/2019/11/24/Java%E8%B8%A9%E5%9D%91%E5%8F%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Jimu Yang">
      <meta itemprop="description" content="积木杨的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="积木杨">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/11/24/Java%E8%B8%A9%E5%9D%91%E5%8F%B2/" class="post-title-link" itemprop="url">Java踩坑史</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-24 01:58:08" itemprop="dateCreated datePublished" datetime="2019-11-24T01:58:08+08:00">2019-11-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-19 18:53:30" itemprop="dateModified" datetime="2021-10-19T18:53:30+08:00">2021-10-19</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="list-subList相关"><a href="#list-subList相关" class="headerlink" title="list.subList相关"></a>list.subList相关</h2><p>以java.util.ArrayList为例：<code>java.util.ArrayList#subList</code>方法返回的结果实际类型为：<code>java.util.ArrayList.SubList</code>。它是ArrayList的内部类，持有ArrayList的<code>this</code>，当对SubList进行<code>写</code>操作时，都会检查自己保存的<code>modCount</code>和<code>ArrayList.this.modCount</code>是否一致，这要求了在执行了list.subList()之后，不可以对list进行<code>写</code>操作（会修改modCount），否则subList的<code>写</code>操作就会报ConcurrentModificationException。</p>
<h3 id="SubList检查modCount源码"><a href="#SubList检查modCount源码" class="headerlink" title="SubList检查modCount源码"></a>SubList检查modCount源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ArrayList.<span class="keyword">this</span>.modCount != <span class="keyword">this</span>.modCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="short-equals-1"><a href="#short-equals-1" class="headerlink" title="short.equals(1)"></a>short.equals(1)</h2><h2 id="三元运算符的类型转换"><a href="#三元运算符的类型转换" class="headerlink" title="三元运算符的类型转换"></a>三元运算符的类型转换</h2><p>特别简单的2行代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i = <span class="keyword">null</span>;</span><br><span class="line">        Integer j = <span class="keyword">true</span> ? i : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然而第二行代码会报一个NPE。。。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ java Test</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class="line">        at Test.main(Test.java:4)</span><br></pre></td></tr></table></figure>
<p>用javap可以明显的看到原因：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">javap -c Test</span><br><span class="line">Compiled from <span class="string">&quot;Test.java&quot;</span></span><br><span class="line">public class Test &#123;</span><br><span class="line">  public Test();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial <span class="comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       4: <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: aconst_null</span><br><span class="line">       1: astore_1</span><br><span class="line">       2: aload_1</span><br><span class="line">       3: invokevirtual <span class="comment">#2                  // Method java/lang/Integer.intValue:()I</span></span><br><span class="line">       6: invokestatic  <span class="comment">#3                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">       9: astore_2</span><br><span class="line">      10: <span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>明显的看到执行了<code>Method java/lang/Integer.intValue:()I</code>，再测试<code>Double</code> <code>Float</code> <code>Boolean</code>都发现了这个问题。<br>那么可以得到结论:如果三元运算符<code>:</code>两侧为基本类型和包装类型，那么java编译执行时会将<code>包装类型拆箱处理</code>，这一点有点反直觉也很坑，使用三元运算符需要注意。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jimuyang.github.io/blog/2019/11/17/%E7%AE%80%E6%B4%81%E8%AF%B4%E6%98%8EJava%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Jimu Yang">
      <meta itemprop="description" content="积木杨的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="积木杨">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/11/17/%E7%AE%80%E6%B4%81%E8%AF%B4%E6%98%8EJava%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/" class="post-title-link" itemprop="url">简洁说明Java参数传递</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-17 16:05:36" itemprop="dateCreated datePublished" datetime="2019-11-17T16:05:36+08:00">2019-11-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-21 01:26:42" itemprop="dateModified" datetime="2021-10-21T01:26:42+08:00">2021-10-21</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java程序猿经常撕的一个问题：Java到底是值传递还是引用传递？"><a href="#Java程序猿经常撕的一个问题：Java到底是值传递还是引用传递？" class="headerlink" title="Java程序猿经常撕的一个问题：Java到底是值传递还是引用传递？"></a>Java程序猿经常撕的一个问题：Java到底是值传递还是引用传递？</h1><ul>
<li>甲说，Java都是值传递。我同意</li>
<li>乙说，Java参数传递非基本类型(引用类型)时，传递的是引用。嗯…, 我点了点头</li>
<li>丙说，对基本类型Java传递值的copy，对非基本类型(引用类型)Java传递地址的copy。解释了甲的意思，我点个赞。 </li>
</ul>
<p>不用吵了，其实大家都懂是怎么回事，很多时候只是概念和表达上的歧义，这里我取个巧，用一套“统一”的理论来简洁解释一下 </p>
<h2 id="Java中的引用"><a href="#Java中的引用" class="headerlink" title="Java中的引用"></a>Java中的引用</h2><p>先问是什么，一等重要的事就是搞清楚到底Java中的引用是啥？</p>
<blockquote>
<p>留给官方说明  </p>
</blockquote>
<!-- 这里放一张栈堆图 -->

<p>在“统一”理论指导下，不妨将引用类型看作是一种“特殊”的基本类型。仅仅特殊在：<strong>引用类型的“值”是一个地址</strong>。<br>现在看一下赋值：原来就是<em>值</em>的copy</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋零值</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;        <span class="comment">// </span></span><br><span class="line">Object o = <span class="keyword">null</span>;  <span class="comment">// 可以认为null就是类似0x0000的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">a = <span class="number">1</span>;            <span class="comment">// a的值为1</span></span><br><span class="line">o = <span class="keyword">new</span> Object(); <span class="comment">// o的&quot;值&quot;是一个地址 可以认为new返回的就是堆内地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量间赋值</span></span><br><span class="line"><span class="keyword">int</span> a1 = a;       <span class="comment">// 将a的值(1)copy给a1</span></span><br><span class="line">Object o1 = o;    <span class="comment">// 将o的&quot;值&quot;(地址)copy给o1</span></span><br></pre></td></tr></table></figure>
<p>再看看==：原来就是<em>值</em>是否相等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">a == <span class="number">2</span>;           <span class="comment">// a的值是否等于2</span></span><br><span class="line">o == <span class="keyword">new</span> Object();<span class="comment">// o的&quot;值&quot;(地址)是否和new返回的地址相等</span></span><br></pre></td></tr></table></figure>
<p>final变量的语义也可以统一为变量的“值”初始化后不可更改</p>
<h2 id="Java的参数传递"><a href="#Java的参数传递" class="headerlink" title="Java的参数传递"></a>Java的参数传递</h2><p>我这样来描述Java的参数传递过程：<strong>将实参赋值给形参</strong>。赋值的本质就是<strong>值copy</strong>。所以回到问题本身，我认为：<strong>Java的参数传递都是值传递</strong>。这样的描述是比较准确也比较体现<strong>值copy</strong>的本质的。<br>用一段简洁的代码来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// break point</span></span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    o = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    func(a, o);             <span class="comment">// 帧栈图1</span></span><br><span class="line">    func(<span class="number">1</span>, <span class="keyword">new</span> Object());  <span class="comment">// 帧栈图2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>断点处线程帧栈一览：<br><img src="/images/javaargpass1.jpg"><br><img src="/images/javaargpass2.jpg"> </p>
<p>通过断点后 func方法内执行这2行代码，只会修改func方法栈内的变量a和o的<strong>值</strong>，而不会对main方法栈内的a和o有任何影响，这也是copy的精髓</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line">o = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><ul>
<li></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jimuyang.github.io/blog/2019/11/10/Linux%E5%87%A0%E7%A7%8DIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Jimu Yang">
      <meta itemprop="description" content="积木杨的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="积木杨">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/11/10/Linux%E5%87%A0%E7%A7%8DIO/" class="post-title-link" itemprop="url">几种IO</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-10 17:36:47" itemprop="dateCreated datePublished" datetime="2019-11-10T17:36:47+08:00">2019-11-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-21 01:27:05" itemprop="dateModified" datetime="2021-10-21T01:27:05+08:00">2021-10-21</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="学习Linux环境下的几种IO模型和一些概念"><a href="#学习Linux环境下的几种IO模型和一些概念" class="headerlink" title="学习Linux环境下的几种IO模型和一些概念"></a>学习Linux环境下的几种IO模型和一些概念</h1><h2 id="先列学习和引用资料"><a href="#先列学习和引用资料" class="headerlink" title="先列学习和引用资料"></a>先列学习和引用资料</h2><ul>
<li>Richard Stevens的《UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking》6.2 IO Models</li>
<li>博客：IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇） <a target="_blank" rel="noopener" href="https://blog.csdn.net/historyasamirror/article/details/5778378">https://blog.csdn.net/historyasamirror/article/details/5778378</a></li>
<li>Java NIO Tutorial: <a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-nio/index.html">http://tutorials.jenkov.com/java-nio/index.html</a></li>
</ul>
<h2 id="Linux-IO-Model-（注意和Java中的概念区分"><a href="#Linux-IO-Model-（注意和Java中的概念区分" class="headerlink" title="Linux IO Model （注意和Java中的概念区分"></a>Linux IO Model （注意和Java中的概念区分</h2><blockquote>
<p>引用自 Richard Stevens “UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking” </p>
</blockquote>
<ul>
<li>Blocking IO       阻塞IO</li>
<li>NoneBlocking IO   非阻塞IO</li>
<li>IO Multiplexing   IO多路复用</li>
<li>Signal Driven IO  信号驱动IO（少见 不做了解</li>
<li>Asynchronous IO   异步IO</li>
</ul>
<h3 id="做些说明："><a href="#做些说明：" class="headerlink" title="做些说明："></a>做些说明：</h3><ol>
<li><p>缓存IO/直接IO<br>这是一种对IO的分类 缓存IO又称标准IO，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，数据先从磁盘复制到内核空间的缓冲区，然后从内核空间缓冲区复制到应用程序的地址空间。 </p>
</li>
<li><p>IO相关对象和阶段<br>对于一个network IO而言，一般会涉及到2个系统对象，一个是使用这个IO的进程/线程，一个是系统内核（kernel）<br>当一个read操作发生时，会经历2个阶段：</p>
</li>
</ol>
<ul>
<li>等待数据准备好 wait for the data to be ready</li>
<li>将数据从kernel复制到用户进程中 copy data from kernel to process<br>不同的IO模型的区分正是在这2个阶段的行为不同  </li>
</ul>
<h3 id="Blocking-IO-阻塞IO"><a href="#Blocking-IO-阻塞IO" class="headerlink" title="Blocking IO 阻塞IO"></a>Blocking IO 阻塞IO</h3><p><img src="/images/BlockingIOModel.gif"><br>最大的特点 用户进程从read调用开始阻塞，直到<strong>数据准备好</strong>并<strong>复制到用户进程中</strong>（即read调用返回）之后，阻塞才会结束。</p>
<h3 id="NoneBlocking-IO-非阻塞IO"><a href="#NoneBlocking-IO-非阻塞IO" class="headerlink" title="NoneBlocking IO 非阻塞IO"></a>NoneBlocking IO 非阻塞IO</h3><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：<br><img src="/images/NonblockingIOModel.gif"><br>最大的特点 在<strong>数据准备好</strong>之前的read调用会立即返回一个error（类似数据还没有准备好），直到<strong>数据准备好</strong>之后的read调用会阻塞并将数据<strong>复制到用户进程中</strong>，read结束</p>
<h3 id="IO-Multiplexing-IO多路复用"><a href="#IO-Multiplexing-IO多路复用" class="headerlink" title="IO Multiplexing IO多路复用"></a>IO Multiplexing IO多路复用</h3><p>使用select/poll/epoll实现 本质上和阻塞IO一样，但是通过维护一个fd集合来一次监控多个socket，从而大大提高系统并发数，注意到获取到就绪的fd之后还是需要阻塞的将数据<strong>复制到用户进程中</strong></p>
<ul>
<li>select: fd数组 轮询 O(n) 限连接数</li>
<li>poll: fd链表 轮询 O(n) 无连接数限制 </li>
<li>epoll: event poll 事件驱动 O(1) 只关心活跃的fd<br><img src="/images/IOMultiplexing.gif"></li>
</ul>
<h3 id="Asynchronous-IO-异步IO"><a href="#Asynchronous-IO-异步IO" class="headerlink" title="Asynchronous IO 异步IO"></a>Asynchronous IO 异步IO</h3><p>真正的异步IO是没有环节阻塞的，直到<strong>数据准备好</strong>并<strong>复制到用户进程中</strong>之后才会通知用户进程直接使用<br><img src="/images/AsyncIO.gif"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jimuyang.github.io/blog/2019/01/01/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Jimu Yang">
      <meta itemprop="description" content="积木杨的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="积木杨">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2019/01/01/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">博客搭建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-01 22:46:14" itemprop="dateCreated datePublished" datetime="2019-01-01T22:46:14+08:00">2019-01-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-19 18:37:39" itemprop="dateModified" datetime="2021-10-19T18:37:39+08:00">2021-10-19</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>第一篇博客 记录 Hexo + NexT搭建个人博客的过程<br>2021/10月修改 基于Hexo 5.0重新搭建</p>
<ol>
<li><p>安装<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>并初始化项目</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br><span class="line">$ hexo init &lt;project-name&gt; <span class="comment"># 这里我使用blog</span></span><br></pre></td></tr></table></figure></li>
<li><p>安装<a target="_blank" rel="noopener" href="http://theme-next.iissnan.com/">NexT</a>主题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-theme-next</span><br></pre></td></tr></table></figure>
<p>修改顶层 _config.yml:<br>theme: landscape<br>=&gt; theme: next</p>
</li>
<li><p>启动博客 如果一切顺利可以看到这样的内容: Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></li>
<li><p>发布博客到github page<br>修改顶层 _config.yml deploy部分<br>安装 hexo-deployer-git</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/jimuyang/jimuyang.github.io</span><br><span class="line">  # https://github.com/&lt;username&gt;/&lt;project&gt;</span><br><span class="line">  # branch: gh-pages</span><br></pre></td></tr></table></figure>
<p>deploy到github page</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jimu Yang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/next-boot.js"></script>

  





  





</body>
</html>
